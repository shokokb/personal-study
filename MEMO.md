# Data Structure

## Array & List

* Array
* List
    * Circular LIst（環状リスト）
    * Bidirectional List（双方向リスト）...ポインタの分、容量を食う
* HashTable
    * 開地法（衝突した場合には他の番地を求め、配置）
    * チェイン法（連鎖法）
    * ハッシュ関数を複数使用する方法
    * 線形操作法
    * ハッシュ関数から元の値を推測できない
    * 連想配列として利用

## Stack & Queue
* Stack
* Queue

## Set（集合）
### Trees
* Basic Tree
    * Tree
    * Binary Tree
* Tupple

## Time Complexity
* Big O

# Algorithm

## Sorting Algorithm
* Selection Sort（選択ソート）
* Shaker-Sort
* Com-Sort（コムソート）
* ノームソート
* Shell Sort
* Insertion Sort（挿入ソート）
* Bubble Sort...O(n^2)
* Merge Sort...O()
* Quick Sort
* Bucket Sort
* 基数ソート
* [ソートアルゴリズム12種を可視化してみた](https://qiita.com/r-ngtm/items/f4fa55c77459f63a5228)

## Array Search
* 線形探索
* 2分探索

## Graph Search
* 幅優先探索
*深さ優先探索
* ベルマン・フォード法
* Dijkstra Algorithm 
* A* Algorithm

# Security Algorithm
* ハッシュ関数
* 共通鍵暗号
* 公開鍵暗号
* ハイブリッド暗号方式
* ディフィ・ヘルマン鍵交換法
* メッセージ認証コード
* デジタル署名
* デジタル証明書

# クラスタリング
* k-means方法

# Else
* ユーグリッドの互除法
* 素数判定法
* ページランク
* ハノイの塔
* Knapsack Problem
* ND Problem
* Travasal
* N choosing K Problem
* Manipuration Algorithm
* Recursive Solutions

# System Design

## Class-oriented Design
    * Hieralchies
    * Class
    * Interface
    * Context Swith


# OS

* Thread
* Proess
* Concurrency Issues
* Semaphores
* Mutexes
* Locks
* Resource Allocation

# Management

* Scheduling works

# ブロック型 vs インデント型 プログラミングの比較メモ

## ✅ ブロック型プログラミングとインデント型プログラミングの比較表

| 特徴                         | ブロック型 (Java, JavaScriptなど)                             | インデント型 (Pythonなど)                                   |
|----------------------------|------------------------------------------------------------|----------------------------------------------------------|
| **構文の区切り**              | `{}` や `begin/end` などで開始と終わりを明示                     | インデント（字下げ）によってブロックを示す                   |
| **可読性**                   | 明示的な `{}` により構造が分かりやすい（ただしネストが深いと煩雑）       | コードがすっきり見え、自然言語的（箇条書きに近い）で読みやすい        |
| **コードサイズ**              | ブロック記号により行数が増えやすい                              | インデントにより記述が簡潔で、行数も少なめ                    |
| **書き間違い時のエラー**        | ブロックが明示されているため、括弧の対応ミスを検出しやすい               | インデントが崩れるとエラーが出るが、原因が分かりにくいことがある        |
| **ツールや補完への依存度**     | IDEが自動でブロック補完（`{}`）するため、補完に依存しがち               | エディタのインデント支援があれば書きやすいが、ずれると厄介              |
| **初心者のとっつきやすさ**      | 構文が複雑に見える場合がある（特にC系言語）                         | シンプルで直感的、初心者にとって入りやすい                     |
| **保守性・リファクタ**         | ブロック構造が崩れにくいため安全にリファクタできる                   | インデントの深さミスがバグの元になる可能性                     |
| **スタイル強制のしやすさ**     | コーディングスタイルは人による。標準があっても従わないことがある         | PEP8などでスタイルが厳しく統一されており、読みやすさが保たれる        |

---

## 🧭 結論

- **ブロック型**は「構文的に厳格・安全性高め」「IDEとの親和性が高い」  
- **インデント型**は「読みやすく、コンパクトに書けるが、インデント依存がデリケート」

---

# 🧠 私のコーディングスタイル：ブロック型 × インデント型のハイブリッド

## ✅ スタイルの特徴

| 項目                     | 内容                                                                 |
|------------------------|----------------------------------------------------------------------|
| **基本方針**              | 小さなモジュールや関数はインデントとコメントで簡潔に管理               |
|                        | 大きな処理単位やロジックブロックは、コメントや空行で視覚的にブロック化      |
| **メリット**              | - 可読性の確保（インデントで流れを見やすく）  <br> - 保守性も確保（大ブロックで全体把握） |
| **インデントの役割**        | 箇条書きのように処理のステップを直感的に伝える                            |
| **ブロックの役割**         | 大きな処理や意味の塊を意識づけ、コメントで仕様のまとまりを示す              |
| **使用例**               | - Pythonでのユーティリティ関数群（インデント型に近い） <br> - クラス構造や大きなアルゴリズム（擬似的にブロック構造を明示） |

## 🛠️ ハイブリッドスタイルの実務的メリット

| 効果             | 説明                                                                 |
|------------------|----------------------------------------------------------------------|
| 🔁 リファクタリング容易 | - モジュール構造が明確なので、機能の切り出しや統合がしやすい                    |
| 🚀 スピード維持         | - 小さな単位では構文に気を取られず、頭の流れを止めずにコーディングできる           |
| 🧩 デバッグ効率         | - ブロック単位に区切られていることで、エラーの場所を直感的に絞りやすい             |
| 🧘‍♀️ メンタル負荷軽減     | - 自分の書いたコードの「全体のかたち」が崩れにくく、集中を保ちやすい               |
