# 基本的なデータ構造

## Sequence

データが順に並んでいる構造
データの格納順をインデックスに記録できる
特定の要素へのアクセス・追加・削除ができる

- Array
  - アクセス: O(1) -> randam access
  - 挿入・削除: O(N) 線形的にずらしてゆく
  - 要素数をあらかじめ決めてからデータを格納するため、領域の拡張ができない
  - 配列を拡張する場合は、元の配列の 2 倍の長さの配列を作成し、格納する
  - Python では list に該当する- List
- 連結リスト
  - 各要素に次の要素をリンクさせる。末尾は None。
  - アクセス: O(N) sequencial access(線形探索)
  - 挿入・削除: O(1)
  - Python では deque に該当する
  - 単方向リスト
  - 双方向リスト
    - deque

## Priority Queue

## Tree(木構造)

各要素をノード(node)と呼ぶ
最上階層のノードをルート(root)と呼ぶ
子を持たないノードをリーフ(leaf)と呼ぶ
各ノードを繋ぐ枝をエッジ(edge)と呼ぶ

- Heap
  - TODO: 後述
- Binary Tree
  - Travasal（走査）
    - pre-order
    - in-order
    - post-order
- Binary Search Tree(BST, 二分探索木)
  - 親ノードに対して、左の子ノードは小さく、右の子ノードは大きいという関係が成立する
  - BST での探索は平均で O(logN)となる。
  - BST の最悪のケースは片方の子ノードに N 個が連鎖する場合は、線形探索と同じ、O(N)となる
  - 平衡二分探索木：Tree がアンバランスになった場合には形を修正して、常にバランスを保つ
- Union-Find 木：グループ分けを管理するデータ構造

  - a と b が同じグループに属するか調べる
  - a と b のグループを併合する（併合はできても、分割はできない）
  - Union-Find木に対する操作はO(α(n)) α(n)はアッカーマン関数の逆関数でありO(logN)より高速。

- B-Tree（B 木）：この数を m 個に拡張し、子供の数に自由度を持たせる
- トライ木

## Map

キー(key)とバリュー（value、値）に対応づけて格納する

- Hash(Directory, 辞書, 連想配列)
  - キーからハッシュ関数を用いてハッシュ値を計算し、ハッシュ値をインデックスとして値にアクセスする
  - 2 つの異なるキーからもとまるハッシュ値が「衝突（conflict）」することがある
  - 衝突の解決法
    - クローズドハッシュ法
      - チェイン法（連鎖法）：ハッシュにリストを格納し、衝突した場合、リストに追加する
    - オープンハッシュ法（開地法）
      - 線形捜査法：衝突が発生した場合、次の場所にデータを格納する（再ハッシュ）
      - 二重ハッシュ法：衝突が発生した再ハッシュ時に、別のハッシュ関数を複数使用する
  - アクセス：O(1)　ただし、オープンハッシュ法で線形探索する場合は O(N)
  - 追加・削除：O(1)
  - 条件付き検索には不向きであり、その場合は BST などを利用する
  - ハッシュ関数から元の値を推測できない

## Bag

格納データの順序付けはなく、重複したデータを格納することができる

- Bag
  - 重複を許す
  - 延べ数の計算に有効
- Set
  - 重複を省く
  - 実数の計算に有効
  - Python の内部構造は辞書に類似

## Graph

- ノード（頂点）群とノード間の連結関係を表すエッジ（枝）で構成されるデータ

---

# Stack & Queue

---

# Vector / 配列リスト

---

# スタック領域・ヒープ領域

- スタック領域 - プログラム起動時に一括で確保されるため、後から拡張できない
  　 - スタック領域のカスタマイズが可能である
- ヒープ領域
  　- グローバル変数などを退避する

---

# Python

- list(配列)
  - ランダムアクセス
- deque(双方向リスト)
  - シーケンシャルアクセス（両端）

# Reference

- [Python Time Complexity](https://wiki.python.org/moin/TimeComplexity)
