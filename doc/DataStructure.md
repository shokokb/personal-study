# 基本的なデータ構造

## Sequence

データが順に並んでいる構造
データの格納順をインデックスに記録できる
特定の要素へのアクセス・追加・削除ができる

- Array
    - アクセス: O(1) -> randam access
    - 挿入・削除: O(N) 線形的にずらしてゆく
    - 要素数をあらかじめ決めてからデータを格納するため、領域の拡張ができない
    - 配列を拡張する場合は、元の配列の2倍の長さの配列を作成し、格納する
    - Pythonではlistに該当する- List
    - 各要素に次の要素をリンクさせる。末尾はNone。
    - アクセス: O(N) sequencial access(線形探索)
    - 挿入・削除: O(1)
    - Pythonではdequeに該当する
    - 単方向リスト
    - 双方向リスト
        - deque

## Tree(木構造)

各要素をノード(node)と呼ぶ
最上階層のノードをルート(root)と呼ぶ
子を持たないノードをリーフ(leaf)と呼ぶ
各ノードを繋ぐ枝をエッジ(edge)と呼ぶ

- Heap
    - TODO: 後述
- Binary Search Tree(BST, 二分探索木) 
    - 親ノードに対して、左の子ノードは小さく、右の子ノードは大きいという関係が成立する
    - BSTでの探索は平均でO(logN)となる。
    - BSTの最悪のケースは片方の子ノードにN個が連鎖する場合は、線形探索と同じ、O(N)となる

## Map

キー(key)とバリュー（value、値）に対応づけて格納する

- Hash(Directory, 辞書, 連想配列)
    - キーからハッシュ関数を用いてハッシュ値を計算し、ハッシュ値をインデックスとして値にアクセスする
    - 2つの異なるキーからもとまるハッシュ値が「衝突（conflict）」することがある
    - 衝突の解決法
        - クローズドハッシュ法
            - チェイン法（連鎖法）：ハッシュにリストを格納し、衝突した場合、リストに追加する
        - オープンハッシュ法（開地法）
            - 線形捜査法：衝突が発生した場合、次の場所にデータを格納する（再ハッシュ）
            - 二重ハッシュ法：衝突が発生した再ハッシュ時に、別のハッシュ関数を複数使用する
    - アクセス：O(1)　ただし、オープンハッシュ法で線形探索する場合はO(N)
    - 追加・削除：O(1)
    - 条件付き検索には不向きであり、その場合はBSTなどを利用する
    - ハッシュ関数から元の値を推測できない

## Bag

格納データの順序付けはなく、重複したデータを格納することができる

- Bag
    - 重複を許す
    - 延べ数の計算に有効
- Set
    - 重複を省く
    - 実数の計算に有効
    - Pythonの内部構造は辞書に類似

## Graph

- ノード（頂点）群とノード間の連結関係を表すエッジ（枝）で構成されるデータ

----

# Python

- list(配列)
    - ランダムアクセス
- deque(双方向リスト)
    - シーケンシャルアクセス（両端）

# Reference

- [Python Time Complexity](https://wiki.python.org/moin/TimeComplexity)
